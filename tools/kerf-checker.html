<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Kerf Check - Plasma Vector Validator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #111827;
            color: #F9FAFB;
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        h1 {
            font-size: 28px;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #9CA3AF;
            margin-bottom: 20px;
        }

        .drop-zone {
            background: #374151;
            border: 2px dashed #4B5563;
            border-radius: 8px;
            padding: 40px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            margin-bottom: 20px;
        }

        .drop-zone:hover, .drop-zone.drag-over {
            border-color: #10B981;
            background: #1F4A3D;
        }

        .drop-zone p {
            color: #9CA3AF;
            font-size: 16px;
        }

        .drop-zone .filename {
            color: #10B981;
            font-weight: bold;
            margin-top: 10px;
        }

        .params {
            background: #1F2937;
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            align-items: center;
        }

        .param-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .param-group label {
            font-size: 12px;
            color: #9CA3AF;
        }

        .param-group select, .param-group input {
            background: #374151;
            border: 1px solid #4B5563;
            border-radius: 4px;
            padding: 8px 12px;
            color: #F9FAFB;
            font-size: 14px;
            min-width: 120px;
        }

        .param-group select:focus, .param-group input:focus {
            outline: none;
            border-color: #6B7280;
        }

        .analyze-btn {
            background: #2563EB;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 4px;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: background 0.2s;
        }

        .analyze-btn:hover {
            background: #1D4ED8;
        }

        .analyze-btn:disabled {
            background: #4B5563;
            cursor: not-allowed;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }

        @media (max-width: 800px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .canvas-container {
            background: #1F2937;
            border: 1px solid #374151;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            min-height: 400px;
        }

        #canvas {
            width: 100%;
            height: 100%;
            min-height: 400px;
        }

        .canvas-placeholder {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #6B7280;
            text-align: center;
        }

        .results-panel {
            background: #1F2937;
            border: 1px solid #374151;
            border-radius: 8px;
            padding: 20px;
            display: flex;
            flex-direction: column;
        }

        .status {
            font-size: 18px;
            font-weight: bold;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 1px solid #374151;
        }

        .status.passed {
            color: #10B981;
        }

        .status.failed {
            color: #EF4444;
        }

        .issues-list {
            flex: 1;
            overflow-y: auto;
            max-height: 400px;
        }

        .issue-item {
            padding: 12px;
            border-radius: 4px;
            margin-bottom: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }

        .issue-item:hover {
            background: #374151;
        }

        .issue-item.critical {
            border-left: 3px solid #EF4444;
            background: rgba(239, 68, 68, 0.1);
        }

        .issue-item.warning {
            border-left: 3px solid #F59E0B;
            background: rgba(245, 158, 11, 0.1);
        }

        .issue-icon {
            margin-right: 8px;
        }

        .issue-message {
            font-size: 13px;
            line-height: 1.4;
        }

        .no-issues {
            color: #9CA3AF;
            text-align: center;
            padding: 40px;
        }

        .action-buttons {
            margin-top: 15px;
            padding-top: 15px;
            border-top: 1px solid #374151;
            display: flex;
            gap: 10px;
        }

        .action-btn {
            flex: 1;
            padding: 10px;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            border: none;
            transition: background 0.2s;
        }

        .action-btn.primary {
            background: #10B981;
            color: white;
        }

        .action-btn.primary:hover {
            background: #059669;
        }

        .action-btn.primary:disabled {
            background: #4B5563;
            cursor: not-allowed;
        }

        .action-btn.secondary {
            background: #374151;
            color: #F9FAFB;
            border: 1px solid #4B5563;
        }

        .action-btn.secondary:hover {
            background: #4B5563;
        }

        .hidden {
            display: none;
        }

        .info-bar {
            background: #1E3A5F;
            border: 1px solid #2563EB;
            border-radius: 4px;
            padding: 10px 15px;
            margin-bottom: 20px;
            font-size: 13px;
            color: #93C5FD;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>KERF CHECK</h1>
        <p class="subtitle">Plasma CNC Vector Validator</p>

        <div class="info-bar">
            Validates DXF files for plasma cutting issues before CAM processing. Checks for duplicates, narrow features, small holes, sharp corners, and path spacing.
        </div>

        <div class="drop-zone" id="dropZone">
            <p>Drag & drop DXF file here<br>or click to browse</p>
            <p class="filename hidden" id="filename"></p>
            <input type="file" id="fileInput" accept=".dxf" style="display: none">
        </div>

        <div class="params">
            <div class="param-group">
                <label>Material</label>
                <select id="material">
                    <option value="0.060">16 gauge</option>
                    <option value="0.075" selected>14 gauge</option>
                    <option value="0.105">12 gauge</option>
                    <option value="0.120">11 gauge</option>
                    <option value="0.135">10 gauge</option>
                    <option value="0.1875">3/16 inch</option>
                    <option value="0.250">1/4 inch</option>
                    <option value="0.375">3/8 inch</option>
                    <option value="0.500">1/2 inch</option>
                </select>
            </div>
            <div class="param-group">
                <label>Amperage</label>
                <input type="number" id="amperage" value="35" min="20" max="100" step="5">
            </div>
            <div class="param-group">
                <label>Kerf Width (in)</label>
                <input type="number" id="kerf" value="0.053" min="0.030" max="0.150" step="0.001">
            </div>
            <button class="analyze-btn" id="analyzeBtn" disabled>ANALYZE</button>
        </div>

        <div class="main-content">
            <div class="canvas-container">
                <canvas id="canvas"></canvas>
                <div class="canvas-placeholder" id="canvasPlaceholder">
                    Load a DXF file to preview
                </div>
            </div>

            <div class="results-panel">
                <div class="status" id="status">No file loaded</div>
                <div class="issues-list" id="issuesList">
                    <div class="no-issues">Load a file and click Analyze</div>
                </div>
                <div class="action-buttons">
                    <button class="action-btn secondary" id="exportBtn" disabled>Export Report</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // DXF PARSER
        // ============================================
        class DXFParser {
            constructor() {
                this.paths = [];
                this.bounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };
            }

            parse(content) {
                this.paths = [];
                this.bounds = { minX: Infinity, minY: Infinity, maxX: -Infinity, maxY: -Infinity };

                const lines = content.split('\n').map(l => l.trim());
                const entities = this.extractEntities(lines);

                for (const entity of entities) {
                    const path = this.parseEntity(entity);
                    if (path && path.points.length >= 2) {
                        this.paths.push(path);
                        this.updateBounds(path.points);
                    }
                }

                return { paths: this.paths, bounds: this.bounds };
            }

            extractEntities(lines) {
                const entities = [];
                let inEntities = false;
                let currentEntity = null;

                for (let i = 0; i < lines.length; i++) {
                    const code = parseInt(lines[i]);
                    const value = lines[i + 1];

                    if (code === 0 && value === 'ENTITIES') {
                        inEntities = true;
                        i++;
                        continue;
                    }

                    if (code === 0 && value === 'ENDSEC' && inEntities) {
                        if (currentEntity) entities.push(currentEntity);
                        break;
                    }

                    if (inEntities && code === 0) {
                        if (currentEntity) entities.push(currentEntity);
                        currentEntity = { type: value, data: {} };
                        i++;
                        continue;
                    }

                    if (currentEntity && !isNaN(code)) {
                        if (!currentEntity.data[code]) {
                            currentEntity.data[code] = [];
                        }
                        currentEntity.data[code].push(value);
                        i++;
                    }
                }

                return entities;
            }

            parseEntity(entity) {
                switch (entity.type) {
                    case 'LINE': return this.parseLine(entity);
                    case 'CIRCLE': return this.parseCircle(entity);
                    case 'ARC': return this.parseArc(entity);
                    case 'LWPOLYLINE': return this.parseLWPolyline(entity);
                    case 'POLYLINE': return this.parsePolyline(entity);
                    default: return null;
                }
            }

            parseLine(entity) {
                const x1 = parseFloat(entity.data[10]?.[0]) || 0;
                const y1 = parseFloat(entity.data[20]?.[0]) || 0;
                const x2 = parseFloat(entity.data[11]?.[0]) || 0;
                const y2 = parseFloat(entity.data[21]?.[0]) || 0;

                return {
                    points: [[x1, y1], [x2, y2]],
                    isClosed: false,
                    isCircle: false,
                    type: 'line'
                };
            }

            parseCircle(entity) {
                const cx = parseFloat(entity.data[10]?.[0]) || 0;
                const cy = parseFloat(entity.data[20]?.[0]) || 0;
                const r = parseFloat(entity.data[40]?.[0]) || 0;

                const points = [];
                const segments = 64;
                for (let i = 0; i <= segments; i++) {
                    const angle = (2 * Math.PI * i) / segments;
                    points.push([cx + r * Math.cos(angle), cy + r * Math.sin(angle)]);
                }

                return {
                    points,
                    isClosed: true,
                    isCircle: true,
                    center: [cx, cy],
                    radius: r,
                    type: 'circle'
                };
            }

            parseArc(entity) {
                const cx = parseFloat(entity.data[10]?.[0]) || 0;
                const cy = parseFloat(entity.data[20]?.[0]) || 0;
                const r = parseFloat(entity.data[40]?.[0]) || 0;
                let startAngle = (parseFloat(entity.data[50]?.[0]) || 0) * Math.PI / 180;
                let endAngle = (parseFloat(entity.data[51]?.[0]) || 360) * Math.PI / 180;

                if (endAngle <= startAngle) endAngle += 2 * Math.PI;

                const points = [];
                const segments = Math.max(16, Math.floor(32 * (endAngle - startAngle) / (2 * Math.PI)));
                for (let i = 0; i <= segments; i++) {
                    const angle = startAngle + (endAngle - startAngle) * i / segments;
                    points.push([cx + r * Math.cos(angle), cy + r * Math.sin(angle)]);
                }

                return {
                    points,
                    isClosed: false,
                    isCircle: false,
                    type: 'arc'
                };
            }

            parseLWPolyline(entity) {
                const xCoords = entity.data[10] || [];
                const yCoords = entity.data[20] || [];
                const flags = parseInt(entity.data[70]?.[0]) || 0;
                const isClosed = (flags & 1) === 1;

                const points = [];
                const count = Math.min(xCoords.length, yCoords.length);
                for (let i = 0; i < count; i++) {
                    points.push([parseFloat(xCoords[i]), parseFloat(yCoords[i])]);
                }

                if (isClosed && points.length > 0) {
                    points.push([...points[0]]);
                }

                return {
                    points,
                    isClosed,
                    isCircle: false,
                    type: 'lwpolyline'
                };
            }

            parsePolyline(entity) {
                // Basic polyline - would need VERTEX entities for full support
                return null;
            }

            updateBounds(points) {
                for (const [x, y] of points) {
                    this.bounds.minX = Math.min(this.bounds.minX, x);
                    this.bounds.minY = Math.min(this.bounds.minY, y);
                    this.bounds.maxX = Math.max(this.bounds.maxX, x);
                    this.bounds.maxY = Math.max(this.bounds.maxY, y);
                }
            }
        }

        // ============================================
        // GEOMETRY UTILITIES
        // ============================================
        function distance(p1, p2) {
            return Math.sqrt((p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2);
        }

        function pathLength(points) {
            let len = 0;
            for (let i = 0; i < points.length - 1; i++) {
                len += distance(points[i], points[i + 1]);
            }
            return len;
        }

        function pathBounds(points) {
            let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
            for (const [x, y] of points) {
                minX = Math.min(minX, x);
                minY = Math.min(minY, y);
                maxX = Math.max(maxX, x);
                maxY = Math.max(maxY, y);
            }
            return { minX, minY, maxX, maxY };
        }

        function pathCentroid(points) {
            let sx = 0, sy = 0;
            for (const [x, y] of points) {
                sx += x;
                sy += y;
            }
            return [sx / points.length, sy / points.length];
        }

        function boundsOverlap(b1, b2, margin = 0) {
            return !(b1.maxX + margin < b2.minX ||
                     b1.minX - margin > b2.maxX ||
                     b1.maxY + margin < b2.minY ||
                     b1.minY - margin > b2.maxY);
        }

        function hausdorffDistance(points1, points2) {
            function directed(p1, p2) {
                let maxDist = 0;
                for (const pt1 of p1) {
                    let minDist = Infinity;
                    for (const pt2 of p2) {
                        minDist = Math.min(minDist, distance(pt1, pt2));
                    }
                    maxDist = Math.max(maxDist, minDist);
                }
                return maxDist;
            }
            return Math.max(directed(points1, points2), directed(points2, points1));
        }

        function minDistanceBetweenPaths(points1, points2) {
            let minDist = Infinity;
            let closestPoint = points1[0];

            for (const p1 of points1) {
                for (const p2 of points2) {
                    const d = distance(p1, p2);
                    if (d < minDist) {
                        minDist = d;
                        closestPoint = p1;
                    }
                }
            }
            return { distance: minDist, point: closestPoint };
        }

        function getCornerAngles(points) {
            if (points.length < 3) return [];

            const corners = [];
            const n = points.length;
            const closed = distance(points[0], points[n - 1]) < 0.001;
            const count = closed ? n - 1 : n;

            for (let i = 0; i < count; i++) {
                const prev = points[(i - 1 + count) % count];
                const curr = points[i];
                const next = points[(i + 1) % count];

                const v1 = [prev[0] - curr[0], prev[1] - curr[1]];
                const v2 = [next[0] - curr[0], next[1] - curr[1]];

                const dot = v1[0] * v2[0] + v1[1] * v2[1];
                const cross = v1[0] * v2[1] - v1[1] * v2[0];

                const angle = Math.atan2(cross, dot);
                const interiorAngle = 180 - (angle * 180 / Math.PI);

                corners.push({ index: i, angle: interiorAngle, point: curr });
            }

            return corners;
        }

        // ============================================
        // ANALYSIS CHECKS
        // ============================================
        function checkDuplicatePaths(paths, kerfWidth) {
            const issues = [];
            const tolerance = 0.001;
            const nearThreshold = kerfWidth * 0.5;
            const flagged = new Set();

            for (let i = 0; i < paths.length; i++) {
                if (flagged.has(i)) continue;

                for (let j = i + 1; j < paths.length; j++) {
                    if (flagged.has(j)) continue;

                    const b1 = pathBounds(paths[i].points);
                    const b2 = pathBounds(paths[j].points);

                    if (!boundsOverlap(b1, b2, nearThreshold)) continue;

                    const hDist = hausdorffDistance(paths[i].points, paths[j].points);

                    if (hDist < tolerance) {
                        issues.push({
                            severity: 'critical',
                            category: 'duplicate',
                            message: 'Exact duplicate path. Machine will cut twice.',
                            pathIndices: [i, j],
                            location: pathCentroid(paths[j].points)
                        });
                        flagged.add(j);
                    } else if (hDist < nearThreshold) {
                        issues.push({
                            severity: 'critical',
                            category: 'duplicate',
                            message: `Near-duplicate (${hDist.toFixed(3)}" apart). Cuts will merge.`,
                            pathIndices: [i, j],
                            location: pathCentroid(paths[j].points)
                        });
                        flagged.add(j);
                    }
                }
            }

            return issues;
        }

        function checkFeatureWidth(paths, kerfWidth) {
            const issues = [];

            for (let i = 0; i < paths.length; i++) {
                const path = paths[i];
                if (!path.isClosed || path.isCircle || path.points.length < 4) continue;

                const bounds = pathBounds(path.points);
                const width = bounds.maxX - bounds.minX;
                const height = bounds.maxY - bounds.minY;
                const minDim = Math.min(width, height);

                if (minDim < kerfWidth) {
                    issues.push({
                        severity: 'critical',
                        category: 'feature_width',
                        message: `Feature too narrow (${minDim.toFixed(3)}"). Min: ${kerfWidth.toFixed(3)}"`,
                        pathIndices: [i],
                        location: pathCentroid(path.points)
                    });
                } else if (minDim < kerfWidth * 1.5) {
                    issues.push({
                        severity: 'warning',
                        category: 'feature_width',
                        message: `Feature width marginal (${minDim.toFixed(3)}"). Consider widening.`,
                        pathIndices: [i],
                        location: pathCentroid(path.points)
                    });
                }
            }

            return issues;
        }

        function checkOpenPaths(paths) {
            const issues = [];
            const tolerance = 0.005;

            for (let i = 0; i < paths.length; i++) {
                const path = paths[i];
                if (path.isClosed || path.points.length < 3) continue;

                const gap = distance(path.points[0], path.points[path.points.length - 1]);

                if (gap > tolerance && gap < pathLength(path.points) * 0.1) {
                    issues.push({
                        severity: 'warning',
                        category: 'open_path',
                        message: `Open path (gap: ${gap.toFixed(4)}"). Path must be closed.`,
                        pathIndices: [i],
                        location: path.points[0]
                    });
                }
            }

            return issues;
        }

        function checkSmallHoles(paths, kerfWidth, materialThickness) {
            const issues = [];
            const minDiameter = materialThickness * 1.5;

            for (let i = 0; i < paths.length; i++) {
                const path = paths[i];
                if (!path.isClosed) continue;

                let diameter;
                if (path.isCircle && path.radius) {
                    diameter = path.radius * 2;
                } else {
                    const bounds = pathBounds(path.points);
                    diameter = Math.min(bounds.maxX - bounds.minX, bounds.maxY - bounds.minY);
                }

                if (diameter < minDiameter && diameter < 0.5) {
                    const severity = diameter < minDiameter * 0.8 ? 'critical' : 'warning';
                    issues.push({
                        severity,
                        category: 'small_hole',
                        message: `Hole ${diameter.toFixed(3)}" below min ${minDiameter.toFixed(3)}" for material.`,
                        pathIndices: [i],
                        location: path.center || pathCentroid(path.points)
                    });
                }
            }

            return issues;
        }

        function checkCornerRadius(paths, kerfWidth) {
            const issues = [];
            const minAngle = 90;

            for (let i = 0; i < paths.length; i++) {
                const path = paths[i];
                if (!path.isClosed || path.isCircle || path.points.length < 4) continue;

                const corners = getCornerAngles(path.points);

                for (const corner of corners) {
                    if (corner.angle < minAngle * 0.9) {
                        issues.push({
                            severity: 'warning',
                            category: 'corner_radius',
                            message: `Sharp corner (${corner.angle.toFixed(0)}Â°). Add fillet >= ${kerfWidth.toFixed(3)}"`,
                            pathIndices: [i],
                            location: corner.point
                        });
                    }
                }
            }

            return issues;
        }

        function checkPathSpacing(paths, kerfWidth) {
            const issues = [];
            const minSpacing = kerfWidth;
            const warnSpacing = kerfWidth * 1.5;
            const checked = new Set();

            for (let i = 0; i < paths.length; i++) {
                for (let j = i + 1; j < paths.length; j++) {
                    const key = `${i}-${j}`;
                    if (checked.has(key)) continue;

                    const b1 = pathBounds(paths[i].points);
                    const b2 = pathBounds(paths[j].points);

                    if (!boundsOverlap(b1, b2, warnSpacing)) continue;

                    const { distance: dist, point } = minDistanceBetweenPaths(
                        paths[i].points, paths[j].points
                    );

                    if (dist < minSpacing && dist > 0.001) {
                        checked.add(key);
                        issues.push({
                            severity: 'critical',
                            category: 'path_spacing',
                            message: `Paths too close (${dist.toFixed(3)}"). Min: ${minSpacing.toFixed(3)}". Cuts will merge.`,
                            pathIndices: [i, j],
                            location: point
                        });
                    } else if (dist < warnSpacing && dist > minSpacing) {
                        checked.add(key);
                        issues.push({
                            severity: 'warning',
                            category: 'path_spacing',
                            message: `Paths close (${dist.toFixed(3)}"). Consider more spacing.`,
                            pathIndices: [i, j],
                            location: point
                        });
                    }
                }
            }

            return issues;
        }

        function runAnalysis(paths, kerfWidth, materialThickness) {
            const issues = [
                ...checkDuplicatePaths(paths, kerfWidth),
                ...checkFeatureWidth(paths, kerfWidth),
                ...checkOpenPaths(paths),
                ...checkSmallHoles(paths, kerfWidth, materialThickness),
                ...checkCornerRadius(paths, kerfWidth),
                ...checkPathSpacing(paths, kerfWidth)
            ];

            const criticalCount = issues.filter(i => i.severity === 'critical').length;
            const warningCount = issues.filter(i => i.severity === 'warning').length;

            return {
                issues,
                passed: criticalCount === 0,
                criticalCount,
                warningCount
            };
        }

        // ============================================
        // CANVAS RENDERER
        // ============================================
        class CanvasRenderer {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.paths = [];
                this.bounds = null;
                this.problemPaths = {};
                this.highlightedPaths = new Set();
            }

            setData(paths, bounds) {
                this.paths = paths;
                this.bounds = bounds;
                this.problemPaths = {};
                this.highlightedPaths = new Set();
            }

            setProblemPaths(issues) {
                this.problemPaths = {};
                for (const issue of issues) {
                    for (const idx of issue.pathIndices) {
                        if (!this.problemPaths[idx] || issue.severity === 'critical') {
                            this.problemPaths[idx] = issue.severity;
                        }
                    }
                }
            }

            setHighlighted(indices) {
                this.highlightedPaths = new Set(indices);
                this.render();
            }

            render() {
                const { width, height } = this.canvas.getBoundingClientRect();
                this.canvas.width = width * window.devicePixelRatio;
                this.canvas.height = height * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

                // Background
                this.ctx.fillStyle = '#1F2937';
                this.ctx.fillRect(0, 0, width, height);

                if (!this.paths.length || !this.bounds) return;

                // Calculate transform
                const margin = 40;
                const geoWidth = this.bounds.maxX - this.bounds.minX;
                const geoHeight = this.bounds.maxY - this.bounds.minY;

                if (geoWidth === 0 || geoHeight === 0) return;

                const scaleX = (width - 2 * margin) / geoWidth;
                const scaleY = (height - 2 * margin) / geoHeight;
                const scale = Math.min(scaleX, scaleY);

                const offsetX = (width - geoWidth * scale) / 2 - this.bounds.minX * scale;
                const offsetY = (height + geoHeight * scale) / 2 + this.bounds.minY * scale;

                const transform = (x, y) => [
                    x * scale + offsetX,
                    -y * scale + offsetY
                ];

                // Draw paths
                for (let i = 0; i < this.paths.length; i++) {
                    const path = this.paths[i];
                    if (path.points.length < 2) continue;

                    let color, lineWidth;

                    if (this.highlightedPaths.has(i)) {
                        color = '#FFFFFF';
                        lineWidth = 3;
                    } else if (this.problemPaths[i] === 'critical') {
                        color = '#EF4444';
                        lineWidth = 2;
                    } else if (this.problemPaths[i] === 'warning') {
                        color = '#F59E0B';
                        lineWidth = 2;
                    } else {
                        color = '#10B981';
                        lineWidth = 1;
                    }

                    this.ctx.strokeStyle = color;
                    this.ctx.lineWidth = lineWidth;
                    this.ctx.beginPath();

                    const [sx, sy] = transform(...path.points[0]);
                    this.ctx.moveTo(sx, sy);

                    for (let j = 1; j < path.points.length; j++) {
                        const [px, py] = transform(...path.points[j]);
                        this.ctx.lineTo(px, py);
                    }

                    if (path.isClosed) {
                        this.ctx.closePath();
                    }

                    this.ctx.stroke();
                }
            }
        }

        // ============================================
        // APPLICATION
        // ============================================
        const dropZone = document.getElementById('dropZone');
        const fileInput = document.getElementById('fileInput');
        const filenameEl = document.getElementById('filename');
        const materialSelect = document.getElementById('material');
        const amperageInput = document.getElementById('amperage');
        const kerfInput = document.getElementById('kerf');
        const analyzeBtn = document.getElementById('analyzeBtn');
        const canvas = document.getElementById('canvas');
        const canvasPlaceholder = document.getElementById('canvasPlaceholder');
        const statusEl = document.getElementById('status');
        const issuesList = document.getElementById('issuesList');
        const exportBtn = document.getElementById('exportBtn');

        const parser = new DXFParser();
        const renderer = new CanvasRenderer(canvas);

        let currentFile = null;
        let parsedData = null;
        let analysisResult = null;

        // Update kerf when amperage changes
        amperageInput.addEventListener('input', () => {
            const amp = parseInt(amperageInput.value) || 35;
            kerfInput.value = (amp * 0.0015).toFixed(3);
        });

        // File handling
        dropZone.addEventListener('click', () => fileInput.click());

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('drag-over');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('drag-over');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('drag-over');
            const file = e.dataTransfer.files[0];
            if (file && file.name.toLowerCase().endsWith('.dxf')) {
                loadFile(file);
            }
        });

        fileInput.addEventListener('change', (e) => {
            if (e.target.files[0]) {
                loadFile(e.target.files[0]);
            }
        });

        function loadFile(file) {
            currentFile = file;
            filenameEl.textContent = file.name;
            filenameEl.classList.remove('hidden');
            analyzeBtn.disabled = false;

            const reader = new FileReader();
            reader.onload = (e) => {
                parsedData = parser.parse(e.target.result);
                renderer.setData(parsedData.paths, parsedData.bounds);
                renderer.render();
                canvasPlaceholder.classList.add('hidden');

                // Auto-analyze
                analyze();
            };
            reader.readAsText(file);
        }

        analyzeBtn.addEventListener('click', analyze);

        function analyze() {
            if (!parsedData) return;

            const kerfWidth = parseFloat(kerfInput.value) || 0.053;
            const materialThickness = parseFloat(materialSelect.value) || 0.075;

            analysisResult = runAnalysis(parsedData.paths, kerfWidth, materialThickness);

            renderer.setProblemPaths(analysisResult.issues);
            renderer.render();

            // Update status
            if (analysisResult.passed) {
                statusEl.textContent = `PASSED - ${analysisResult.warningCount} warnings`;
                statusEl.className = 'status passed';
            } else {
                statusEl.textContent = `FAILED - ${analysisResult.criticalCount} critical, ${analysisResult.warningCount} warnings`;
                statusEl.className = 'status failed';
            }

            // Update issues list
            issuesList.innerHTML = '';

            if (analysisResult.issues.length === 0) {
                issuesList.innerHTML = '<div class="no-issues">No issues found! Design is ready for cutting.</div>';
            } else {
                for (const issue of analysisResult.issues) {
                    const div = document.createElement('div');
                    div.className = `issue-item ${issue.severity}`;

                    const icon = issue.severity === 'critical' ? 'ðŸ”´' : 'ðŸŸ¡';
                    div.innerHTML = `<span class="issue-icon">${icon}</span><span class="issue-message">${issue.message}</span>`;

                    div.addEventListener('mouseenter', () => {
                        renderer.setHighlighted(issue.pathIndices);
                    });

                    div.addEventListener('mouseleave', () => {
                        renderer.setHighlighted([]);
                    });

                    issuesList.appendChild(div);
                }
            }

            exportBtn.disabled = false;
        }

        exportBtn.addEventListener('click', () => {
            if (!analysisResult || !currentFile) return;

            let report = 'KERF CHECK ANALYSIS REPORT\n';
            report += '='.repeat(50) + '\n\n';
            report += `File: ${currentFile.name}\n`;
            report += `Material: ${materialSelect.options[materialSelect.selectedIndex].text}\n`;
            report += `Amperage: ${amperageInput.value} A\n`;
            report += `Kerf Width: ${kerfInput.value}"\n\n`;
            report += `STATUS: ${analysisResult.passed ? 'PASSED' : 'FAILED'}\n`;
            report += `Critical Issues: ${analysisResult.criticalCount}\n`;
            report += `Warnings: ${analysisResult.warningCount}\n\n`;

            if (analysisResult.issues.length > 0) {
                report += 'ISSUES:\n';
                report += '-'.repeat(50) + '\n';
                analysisResult.issues.forEach((issue, i) => {
                    const severity = issue.severity.toUpperCase();
                    report += `${i + 1}. [${severity}] ${issue.message}\n`;
                });
            }

            const blob = new Blob([report], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = currentFile.name.replace('.dxf', '_kerf_report.txt');
            a.click();
            URL.revokeObjectURL(url);
        });

        // Handle resize
        window.addEventListener('resize', () => {
            if (parsedData) {
                renderer.render();
            }
        });
    </script>
</body>
</html>
